# arbix_core/strategy/base_strategy.py
from abc import ABC, abstractmethod
import pandas as pd
import logging

logger = logging.getLogger(__name__) # Will be arbix_core.strategy.base_strategy

class StrategySignal:
    """
    Represents the signal generated by a strategy.
    """
    def __init__(self, signal_type: str, symbol: str, details: dict = None):
        """
        :param signal_type: "BUY", "SELL", "HOLD", "CLOSE_LONG", "CLOSE_SHORT", "NO_SIGNAL"
        :param symbol: The trading symbol (e.g., "BTCUSDT")
        :param details: Optional dictionary for additional info (e.g., price, confidence)
        """
        self.signal_type = signal_type
        self.symbol = symbol
        self.details = details if details is not None else {}

    def __str__(self):
        return f"Signal(type={self.signal_type}, symbol={self.symbol}, details={self.details})"

class BaseStrategy(ABC):
    """
    Abstract Base Class for all trading strategies.
    """
    def __init__(self, strategy_id: str, symbol: str, config: dict = None):
        """
        :param strategy_id: A unique identifier for this strategy instance.
        :param symbol: The trading symbol this strategy operates on.
        :param config: Strategy-specific configuration parameters.
        """
        self.strategy_id = strategy_id
        self.symbol = symbol
        self.config = config if config is not None else {}
        self.current_klines: pd.DataFrame = pd.DataFrame()
        logger.info(f"Strategy [{self.strategy_id}] initialized for symbol [{self.symbol}] with config: {self.config}")

    @abstractmethod
    def calculate_indicators(self, klines_df: pd.DataFrame) -> pd.DataFrame:
        """
        Calculate necessary technical indicators and add them to the DataFrame.
        This method should be overridden by subclasses.
        It should return the DataFrame with indicators added.
        """
        pass

    @abstractmethod
    def generate_signal(self, klines_with_indicators: pd.DataFrame) -> StrategySignal:
        """
        Generate a trading signal based on the klines and calculated indicators.
        This method should be overridden by subclasses.
        It should analyze the latest row(s) of the DataFrame.
        """
        pass

    def update_data(self, new_klines_df: pd.DataFrame) -> None:
        """
        Update the strategy's internal kline data.
        This base implementation simply replaces the old data.
        Strategies requiring historical accumulation or specific update logic
        can override this method.
        """
        if new_klines_df is not None and not new_klines_df.empty:
            # For simplicity now, we just assign. Later, we might append or combine.
            self.current_klines = new_klines_df
            logger.debug(f"Strategy [{self.strategy_id}] data updated for [{self.symbol}]. New klines count: {len(self.current_klines)}")
        else:
            logger.warning(f"Strategy [{self.strategy_id}] received empty or None data for [{self.symbol}].")


    def run(self) -> StrategySignal | None:
        """
        Execute one cycle of the strategy: calculate indicators and generate a signal.
        """
        if self.current_klines.empty:
            logger.warning(f"Strategy [{self.strategy_id}] run: No kline data available for {self.symbol}. Cannot generate signal.")
            return StrategySignal("NO_SIGNAL", self.symbol, {"reason": "No kline data"})

        try:
            klines_with_indicators = self.calculate_indicators(self.current_klines.copy()) # Use a copy to avoid modifying original
            if klines_with_indicators is None or klines_with_indicators.empty:
                logger.error(f"Strategy [{self.strategy_id}] run: calculate_indicators returned empty or None for {self.symbol}.")
                return StrategySignal("NO_SIGNAL", self.symbol, {"reason": "Indicator calculation failed"})

            signal = self.generate_signal(klines_with_indicators)
            logger.info(f"Strategy [{self.strategy_id}] run for [{self.symbol}] generated signal: {signal}")
            return signal
        except Exception as e:
            logger.error(f"Strategy [{self.strategy_id}] run: Exception during execution for {self.symbol}: {e}", exc_info=True)
            return StrategySignal("NO_SIGNAL", self.symbol, {"reason": f"Exception: {str(e)}"})

    def get_name(self) -> str:
        """Returns the name of the strategy (class name by default)."""
        return self.__class__.__name__